import{_ as s,c as a,o as n,a3 as e}from"./chunks/framework.KDVdU9Cg.js";const g=JSON.parse('{"title":"常见问题","description":"","frontmatter":{"title":"常见问题"},"headers":[],"relativePath":"support/faq.md","filePath":"support/faq.md"}'),i={name:"support/faq.md"},p=e(`<h3 id="日志文件在哪" tabindex="-1">日志文件在哪? <a class="header-anchor" href="#日志文件在哪" aria-label="Permalink to &quot;日志文件在哪?&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 宿主机</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tail</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /data/orion-visor-space/docker-volumes/orion-visor-service/root-orion/logs/orion-visor/app.log</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 容器内</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tail</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /root/orion/logs/orion-visor/app.log</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 滚动日志 .../logs/orion-visor/rolling/*</span></span></code></pre></div><h3 id="数据误删除怎么办" tabindex="-1">数据误删除怎么办? <a class="header-anchor" href="#数据误删除怎么办" aria-label="Permalink to &quot;数据误删除怎么办?&quot;">​</a></h3><p>数据库的数据都采用了逻辑删除, 可以将已删除的数据中的 <code>deleted</code> 字段改为 <code>0</code><br> 如果不知道数据是哪一条, 可以查询用户操作日志, 点击 <code>参数</code> 寻找操作的id</p><h3 id="执行命令时为什么会找不到环境变量" tabindex="-1">执行命令时为什么会找不到环境变量? <a class="header-anchor" href="#执行命令时为什么会找不到环境变量" aria-label="Permalink to &quot;执行命令时为什么会找不到环境变量?&quot;">​</a></h3><p>可以在执行命令的第一行设置 <code>source /etc/profile</code> 来加载环境变量</p><h3 id="命令中途执行失败如何设置中断执行" tabindex="-1">命令中途执行失败如何设置中断执行? <a class="header-anchor" href="#命令中途执行失败如何设置中断执行" aria-label="Permalink to &quot;命令中途执行失败如何设置中断执行?&quot;">​</a></h3><p>可以在执行命令的第一行设置 <code>set -e</code><br> 作用是: 当执行出现意料之外的情况时, 立即退出</p><h3 id="在调度任务、批量执行-命令执行成功的依据是什么" tabindex="-1">在调度任务、批量执行 命令执行成功的依据是什么? <a class="header-anchor" href="#在调度任务、批量执行-命令执行成功的依据是什么" aria-label="Permalink to &quot;在调度任务、批量执行 命令执行成功的依据是什么?&quot;">​</a></h3><p>是获取命令的 <code>exitcode</code> 判断是否为 <code>0</code> 如果非0则代表命令执行失败<br> 同理, 在命令的最后一行设置 <code>exit 1</code> 结果将会是失败, 可以用此来中断后续流程</p><h3 id="调度任务、批量执行-的日志文件中如何只保存原始输出" tabindex="-1">调度任务、批量执行 的日志文件中如何只保存原始输出? <a class="header-anchor" href="#调度任务、批量执行-的日志文件中如何只保存原始输出" aria-label="Permalink to &quot;调度任务、批量执行 的日志文件中如何只保存原始输出?&quot;">​</a></h3><p>修改 <code>application.yaml</code> <code>app.exec-log.append-ansi</code> 为 <code>false</code></p><h3 id="sftp-为什么有些文件无法编辑" tabindex="-1">SFTP 为什么有些文件无法编辑? <a class="header-anchor" href="#sftp-为什么有些文件无法编辑" aria-label="Permalink to &quot;SFTP 为什么有些文件无法编辑?&quot;">​</a></h3><p>只有普通文件可以在线编辑, 也就是 attr 为 <code>-</code> 开头的文件, 且文件大小不超过 <code>2MB</code> (默认)<br> 修改 <code>.env.production</code> <code>VITE_SFTP_PREVIEW_MB</code> 改为一个合适的大小(MB) 重新构建</p><h3 id="为什么使用密钥认证还是无法连接机器" tabindex="-1">为什么使用密钥认证还是无法连接机器? <a class="header-anchor" href="#为什么使用密钥认证还是无法连接机器" aria-label="Permalink to &quot;为什么使用密钥认证还是无法连接机器?&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 升级 openssh</span></span>
<span class="line"><span>yum update openssh</span></span>
<span class="line"><span>sshd -v (我的版本: OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 生成密钥时添加参数 -m PEM</span></span>
<span class="line"><span>ssh-keygen -t rsa -m PEM</span></span>
<span class="line"><span>chmod 700  ~/.ssh</span></span>
<span class="line"><span>chmod 700  ~/.ssh/authorized_keys </span></span>
<span class="line"><span></span></span>
<span class="line"><span># 修改 sshd 配置 /etc/ssh/sshd_config</span></span>
<span class="line"><span>PubkeyAuthentication yes</span></span>
<span class="line"><span>RSAAuthentication yes</span></span>
<span class="line"><span>AuthorizedKeysFile .ssh/authorized_keys</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 重启 sshd 服务</span></span>
<span class="line"><span>service sshd restart</span></span></code></pre></div>`,16),o=[p];function t(l,h,c,d,r,k){return n(),a("div",null,o)}const _=s(i,[["render",t]]);export{g as __pageData,_ as default};
